# 20200620_네번째수업

## Spring web.xml에서 config 읽는 법
```
<servlet>
	<servlet-name>dispatcher</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextClass</param-name>
		<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>			
	</init-param>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>
			config.MvcConfig
			config.ControllerConfig
		</param-value>	
	</init-param>
	<load-on-startup>1</load-on-startup>
</servlet>
```
- config.MvcConfig는 결국 = src/main/java의 config패키지 안에 MvcConfig.class를 의미한다.
- 즉 com.stone.infolabs.boardmanage.config라고 패키지를 만들었다면 아래처럼 되어야 한다. 
```
<param-value>
	com.stone.infolabs.boardmanage.config.MvcConfig
	com.stone.infolabs.boardmanage.config.ControllerConfig
</param-value>	
```
- MvcConfig와 ControllerConfig는 하나의 템플릿이라고 할 수 있다.
- 환경설정을 잡으려고 만들어 놓은 것

## 뷰와 Controller 사이의 접근방법
|컨트롤반환|컨트롤반환 자료형|
|------|---|
|뷰 only|void|
|뷰|String|
|뷰+데이터|ModelAndView|

## void로 Controller를 return하면 어떻게 될까??
- RequestMapping에 있는 bbb를 가져오고 싶음.
```
//컨트롤러에 다음과 같이 지정
@RequestMapping("bbb")
public void question() {
	return ;
}
//bbb.jsp 지정

하면 bbb를 호출한다.
200OK로 바로 인식하는건 스프링에서 해주는 듯 하다.
```

## WEB-INF 아래로 직접요청하면 404에러가 발생한다.
해결방법 : tomcat의 web.xml에 가서 docBase = "infoslab2" pathh="infoslab2" 식으로 변경한다. 

## ControllerConfig에 @Bean 어노테이션은 Class단위로 작성되어야 한다
> 메소드 단위인줄 알았는데 class 단위다!!!!!!!!!!!!!!!!


## @Controller를 등록하고 다시 @Bean을 써줘야 하는 이유??
- spring boot에서는 그냥 @Controller만 쓰면 되는거 같은데 Spring에서는 왜 @Controller를 등록하고 다시 @Bean을 등록해야 할까?

**[ 스프링에서의 빈이란? ]**
```
우선 스프링은 경량 컨테이너로서 객체 생성, 소멸과 같은 Life Cycle을 관리하며 스프링 컨테이너로부터 필요한 객체를 얻을 수 있다. 

스프링 컨테이너에 의해서 자바 객체가 만들어지게 되면 이 객체를 스프링은 스프링 빈(Bean)이라고 부른다.

스프링 빈과 자바 일반 객체와의 차이점은 없고 스프링 컨테이너에 의해 만들어진 객체를 스프링 빈이라고 부를 뿐이다.

스프링에서 빈을 등록하는 방법이 두가지라고 한다.
```

#### 1번 - [@Component & @Autowired] 
```
스프링부트에서 사용자 클래스를 스프링 빈으로 등록하는 가장 쉬운 방법은 클래스 선언부 위에 Component Annotation을 사용하는 것이다.  
@Component가 붙은 클래스는 스프링 빈 객체로 등록이 되어 객체 생성/삭제를 스프링에서 관리할 수 있다.
```
#### 2번 - [ @Bean & @Configuration ]
```
스프링 빈을 생성하는 또 다른 방법으로는 자바 설정 클래스를 이용하는 것이다. 

초기 스프링 기반 개발에서 빈 생성은 xml로 된 스프링 설정파일을 통해 이루어졌으며 지금 자바 클래스에서 관련 설정을 대신하는 방법을 주로 사용한다. 

물론 필요에 따라 xml설정은 아직도 사용이 가능하다.

설정 클래스는 @Configuration 어노테이션을 클래스 선언부 앞에 추가를 하면 된다. 또한 특정 타입을 리턴하는 메서드를 만들고 @Bean 어노테이션을 붙여주면 자동으로 해당 타입의 빈 객체가 생성된다.

@Bean 어노테이션의 주요 내용은 다음과 같다.
 > @Configuration 설정된 클래스의 메서드에서 사용가능.
 > 메서드의 리턴 객체가 스프링 빈 객체임을 선언함.
 > 빈의 이름은 기본적으로 메서드 이름이 됨.
 > @Bean(name=”name”) 으로 이름 변경 가능.
 > @Scope 을 통해 객체 생성을 조정할 수 있음.
 > @Component 애너테이션을 통해 @Configuration 없이도 빈 객체를 생성할수도 있음.
 > 빈 객체에 init(), destroy() 등 라이프사이클 메서드를 추가한 다음 @Bean 에서 지정할 수 있음.
```
근데 같은 메소드에 대해 두번 선언하면 이런 에러가 난다.
```
@Configuration
public class ControllerConfig {
	@Bean
	public 게시물관리자 BoardAdmin() {
		return new 게시물관리자();
	}
	
	@Bean
	public 게시물관리자 등록하다() {
		return new 게시물관리자();
	}
}
```
이렇게 쓰면 게시물관리자() 라는 Controller가 뭘 선택해야 할지 해깔려하는걸로 보인다.
```
심각: 웹 애플리케이션 [/infoslab] 내의 서블릿 [dispatcher]이(가) load() 예외를 발생시켰습니다.
java.lang.IllegalStateException: Ambiguous mapping. Cannot map '등록하다' method 
public java.lang.String com.stone.infolabs.boardmanage.presentation.게시물관리자.준비하다()
to {[/prepare_board],methods=[GET]}: There is already 'BoardAdmin' bean method
```

따라서 하나의 컨트롤러에는 하나의 new를 @Bean에 등록하니까 에러가 안났다... 
내 생각에 Controller Class당 하나여야 에러가 발생을 안하는데 문제가 생긴다.
```
// 즉, 이것만 써야 되는거임..
@Configuration
public class ControllerConfig {
	@Bean
	public 게시물관리자 BoardAdmin() {
		return new 게시물관리자();
	}
}
```
그래서 이때 사용하는게 
#### [ @Primary & @Qualifier ]

```
@Primary: @Bean 혹은 @Component 에 함께 사용하며 객체 생성의 우선권을 부여.
@Qualifier: @Autowired에 함께 사용하며 Bean 의 이름이 같은 객체를 찾음.
```

Bean에 이름을 지정하는 방법은 다음과 같다.
```
1) 이름을 명시하지 않는경우
@Component: 소문자로 시작하는 클래스이름이 자동으로 사용됨.
@Bean: 소문자로 시작하는 메서드이름이 자동으로 사용됨.

2) 이름을 명시하는 경우
@Component: @Component(“이름”)과 같이 사용.
@Bean: @Bean(name=”이름”)과 같이 사용.
오토와이어링시 이름 사용 @Autowired 에서 특정 이름의 Bean 을 가지고 오려면 @Qualifier 어노테이션을 사용해야 한다.
```
먼저 이렇게 @Configuration과 @Bean이 있다고 가정한다.
```
@Configuration
public class ConfigurationExample {

    @Bean
    public Weapon superAK47() {
        AK47 ak47 = new AK47();
        return ak47;
    }

    @Bean
    public Weapon superAK47_Black() {
        AK47_Black ak47_black = new AK47_Black();
        return ak47_black;
    }
}
```


여기서는 @Bean에 이름을 부여하고 찾는 것으로 다음과 같이 소스코드를 수정한다.
```
// ConfigurationExample.java
@Bean(name="ak47")
...

@Bean(name="ak47_b")
...

// Review7WeekApplication.java
@Autowired
@Qualifier("ak47_b")
Weapon weapon
```
위의 소스코드를 실행하면 객체 생성의 우선권을 부여할 수 있다고 한다. Class만들 때 뭘 우선적으로 만들까? 가 된다는 것이다.

@Qualifier말고도 @Primary를 사용해도 객체 생성의 우선권이 부여된다.

```
// ConfigurationExample.java
@Bean(name="ak47")
@Primary
...

@Bean(name="ak47_b")
...


// Review7WeekApplication.java
@Autowired
Weapon weapon
...
```

@Primary 어노테이션은 자바 설정 클래스에서도 사용이 가능하고 스프링 어노테이션(@Component) 밑에 붙여서도 사용이 가능하다.
그렇다면 만약에 @Qualifier와 @Primary 중에 어떤 것에 객체 생성의 우선권이 부여될까?
```
@Qualifier가 @Primary보다 강력하다는 것을 알 수 있다.
```